# C++高性能服务器框架

## 简介

仿[sylar: C++高性能分布式服务器框架](https://github.com/sylar-yin/sylar)的基于C++17实现的高性能服务器框架。

参考资料：

- [C++高性能服务器框架 – SYLAR – 02日志模块 – sylar的博客](http://www.sylar.top/blog/?p=147)
- [C++_古猜..的博客-CSDN博客](https://blog.csdn.net/qq_35099224/category_12613947.html)
- [日志模块 - 类库与框架 - 程序员的自我修养 (midlane.top)](https://www.midlane.top/wiki/pages/viewpage.action?pageId=10061019#id-日志模块-LogEventWrap)
- [sylar C++高性能服务器框架——日志模块 - 掘金 (juejin.cn)](https://juejin.cn/post/7241821748211777593#heading-51)

## 项目结构

本项目编译生成静态库 `libconet.a`，测试代码在tests下面。

### 日志模块

日志模块：`Logger` 输出日志，是现场构造一个 `LogEvent` ，然后经过 `LogFormatter`，再由 `LogAppender` 输出到目的地。

- `LogEvent`：封装后的日志消息（即日志的元数据）
  - `LogLevel`：日志等级
- `LogFormatter`：日志格式化器
- `LogAppender`：日志输出器
  - `StdoutLogAppender`：标准输出日志输出器
  - `FileLogAppender`：文件日志输出器
- `Logger`：日志器，组合使用上述组件
- `LogConfig`：日志器配置信息类
- `LogAppenderConfig`：日志输出器的配置信息类
- `LogEventWrapper`：日志的RAII风格打印（析构时打印日志）

### 配置模块

用于定义/声明配置项，从配置文件中加载用户配置，并在配置发生变化时自动重新加载

- `ConfigItemBase`：所有配置项的虚基类，提供 `toString/fromString` 公共接口，定义了配置项的名字和描述
- `ConfigItem`：所有配置项的实现类（模板），配置项的值由模板形参决定，配有 `toString/fromString` 方法的实现
- `Config`：解析YAML文件，监听配置项更改，管理所有配置项的单例函数类（没有成员变量，所有的成员函数均为 `static`）
- `meha::lexical_cast`：封装 `boost::lexical_cast` 的类型转换函数为仿函数模板，并为各YAML数据类型特化实现自己的版本，从而实现YAML数据类型和 `string` 的相互转换，用于支撑实现 `toString/fromString` 方法

- [ ] 加入命令行参数
- [ ] 添加正则匹配

### 线程模块

> 为什么不直接使用C++11提供的thread类。按sylar的描述，因为thread其实也是基于pthread实现的。并且C++11里面没有提供读写互斥量，RWMutex，Spinlock等，在高并发场景，这些对象是经常需要用到的，所以选择自己封装pthread。

`Thread`：线程类，构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用`std::bind`进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。

线程同步类（这部分被拆分到mutex.hpp）中：

- `Semaphore`: 计数信号量，基于`sem_t`实现
- `Mutex`: 互斥锁，基于`pthread_mutex_t`实现
- `RWMutex`: 读写锁，基于`pthread_rwlock_t`实现
- `Spinlock`: 自旋锁，基于`pthread_spinlock_t`实现
- `CASLock`: 原子锁，基于`std::atomic_flag`实现

注意：

- 关于线程入口函数。sylar的线程只支持void(void)类型的入口函数，不支持给线程传参数，但实际使用时可以结合`std::bind`来绑定参数，这样就相当于支持任何类型和数量的参数。

- 关于子线程的执行时机。sylar的线程类可以保证在构造完成之后线程函数一定已经处于运行状态，这是通过一个信号量来实现的，构造函数在创建线程后会一直阻塞，直到线程函数运行并且通知信号量，构造函数才会返回，而构造函数一旦返回，就说明线程函数已经在执行了。

- 关于线程局部变量。sylar的每个线程都有两个线程局部变量，一个用于存储当前线程的Thread指针，另一个存储线程名称，通过Thread::GetThis()可以拿到当前线程的指针。一般都要求线程有名称

- 关于范围锁。sylar大量使用了范围锁来实现互斥，范围锁是指用类的构造函数来加锁，用析造函数来释放锁。这种RAII方式可以简化锁的操作，也可以避免忘记解锁导致的死锁问题。

TODO:

- [ ] 添加线程池（sylar没做线程池是由于该框架主要用协程做高并发的任务）
- [ ] 合理设定创建线程和协程失败时是否是致命错误

### 协程模块

#### 协程类

> [协程模块 - 类库与框架 - 程序员的自我修养 (midlane.top)](https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060957#id-协程模块-ucontext_t接口)

协程是一种看起来花里胡哨，并且使用起来也花里胡哨的函数，用于在单线程中暂时让出CPU（yield）和获得CPU（resume）来执行不同的代码块，从而实现单线程内的并发。

因此，协程只是利用所属线程的CPU核心来单核并发，并不能像线程那样利用多核并行。属于用户态调度的。

##### 并发安全

由于协程涉及到执行流，因此并发访问临界区自然需要加锁。此时的锁应当是协程级别的锁，才能避免不同协程之间的并发安全。

由于协程们运行在同一个线程中，因此禁止在协程中重复加线程级别的锁，否则就是同一线程内递归上锁导致死锁了。

##### 协程原语

对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。

##### 协程上下文

协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用 `ucontext_t` 结构体表示，配有对应的API。

##### 协程调度

同样是单线程环境下，协程的yield和resume一定是同步进行的，一个协程的yield，必然对应另一个协程的resume，因为线程不可能没有执行主体。并且，协程的yield和resume是完全由应用程序来控制的。与线程不同，线程创建之后，线程的运行和调度也是由操作系统自动完成的，但协程创建后，协程的运行和调度都要由应用程序来完成。

- 所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用起协程的方式运行这个函数；
- 所谓协程调度，其实就是创建一批的协程，然后再创建一个调度协程来调度执行这些协程（协程可以在被调度时继续向调度器添加新的调度任务）；
- 所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；
- 所谓定时器，就是给调度协程预设一个协程对象，等定时时间超时就恢复预设的协程对象。

##### 协程状态

仿照进程的5状态（创建态、就绪态、运行态、阻塞态、终止态）模型，将协程状态简化为4个状态：

```mermaid
graph LR
INIT -->|第一次调入执行| READY
READY -->|resume:获得处理机调入执行| EXEC
EXEC -->|yield:放弃处理机加入调度| READY
EXEC -->|协程函数运行结束| TERM
```

- 创建态INIT：协程刚创建，还没有开始执行（只相当于标记位，调入会直接变到EXEC）
- 就绪态READY：协程函数还没有开始执行（可能是刚创建，或被挂起）
- 运行态EXEC：协程函数正在执行
- 终止态TERM：协程函数运行结束

设计成这样是基于几点考虑：

1. INIT和TERM是由于reset重置协程函数不应在协程函数已经执行过的情况下重置，因此需要区分状态
2. 由于协程属于用户态调度执行的，隶属于线程，因此不应调用线程原语阻塞，所谓的协程阻塞行为应该由用户态调度器`Scheduler`自行管理和实现

##### 协程模块设计

本部分是基于glibc的 `ucontext_t` 实现非对称协程。即**子协程只能和主协程切换，而不能和另一个子协程切换。由主协程选出一个子协程来调度运行，而不允许子协程有调度其他协程的能力**。并且在程序结束时，一定要再切回主协程，以保证程序能正常结束，像下面这样：

![image](https://img2024.cnblogs.com/blog/3077699/202406/3077699-20240610230857545-699286863.png)

sylar使用线程局部变量（C++11`thread_local`变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。

对于每个线程的协程上下文，sylar设计了两个线程局部变量来存储协程上下文信息（对应源码的`t_current_fiber`和`t_master_fiber`），也就是说，一个线程在任何时候最多只能知道两个协程的上下文（当前执行的和主协程的），前者用于调度执行当前协程，后者用于切回主协程。

sylar的非对称协程代码实现简单，并且在后面实现协程调度时可以做到公平调度，缺点是子协程只能和线程主协程切换，意味着子协程无法创建并运行新的子协程，并且在后面实现协程调度时，完成一次子协程调度需要先切换回主协程，这会额外多切换一次上下文。

##### 协程模块实现

（1）`ucontext_t` 结构体定义

```c
// 上下文结构体是平台相关的，因为不同平台的寄存器不一样
// 下面列出的是所有平台都至少会包含的4个成员
typedef struct ucontext_t {
    struct ucontext_t *uc_link;   // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
    sigset_t          uc_sigmask; // 当前上下文的信号屏蔽掩码
    stack_t           uc_stack;   // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
    mcontext_t        uc_mcontext;// 平台相关的上下文具体内容，包含寄存器的值
    ...
} ucontext_t;

// 寄存器值结构体
typedef struct {
    gregset_t __ctx(gregs);		// 所装载寄存器
    fpregset_t __ctx(fpregs);	// 寄存器的类型
} mcontext_t;

// 栈内存结构体
typedef struct {
    void *ss_sp;	// 栈顶指针
    int ss_flags;	// 备用栈状态
    size_t ss_size;	// 栈空间大小
} stack_t;
```

（2）配套API

```c
// 获取当前的上下文
int getcontext(ucontext_t *ucp);
 
// 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
int setcontext(const ucontext_t *ucp);
 
// 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数。
// 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间；
// 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文；如果不赋值uc_link，那func函数结束时必须手动调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就没有执行流了
// makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行
void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);
 
// 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，
// 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
// swapcontext是非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换
int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
```

#### 协程调度器



TODO:

- [x] 写一下util.h
- [x] 写一下exception
- [ ] 看一下uncontext的用法
- [ ] 协程调度器
- [ ] 支持内存池

## 杂谈

**1.方法论**

1.1如何阅读这个大型项目

（1）先建好环境，让程序能运行，玩一遍

当你拿到一个程序后，即使你不看代码，你也应该知道它是干什么的吧！干啥都不知道，不用看了。

（2）看想办法掌握程序的结构

作者微博、Google、百度、PDSN、等找到程序的体系结构，完整的文档

（3）先体系再细节；先平面再线点。

先整体再局部，先平面再线点。"大胆猜测，小心求证"。在阅读程序的过程中，我们往往对某一处或几处逻辑不肯定，可能是这样，也可能是那样。

（4）断点调试、日志调试。

（5）忽略细节，先前不要关注分支

Main开始一字一句的解读，遇到一个问题，直到他认为这个问题已经处理不再是个问题的时候，才进行下一步。

这是一个做事方法问题：这样无疑会导致整个进度的延缓。若我们一开始只关注整体结构（一个宏观的大概的流程），而忽略掉那些细支末节，则很有利。

那些可以忽略呢？

如有些函数一看函数名便知道是干什么的，没有要一开始便深入。

有些系统中的分支（如某此特殊场景下才执行的逻辑）、不重要的功能，则一扫而过

（6）其它

善用搜索引擎

先整体再局部，先宏观再微观，先流程再细节。



1.2.如何阅读大型项目的C++代码

章节0:了解文档

要搞清楚别人的代码，首先，你要了解代码涉及的领域知识，这是最重要的，不懂领域知识，只看代码本身，不可能搞的明白。

其次，你得找各种文档：需求文档（要做什么），设计文档（怎么做的），先搞清楚你即将要阅读是什么玩意，至少要把代码的整体结构搞清楚：整体架构如何，有几个模块，模块间通信方式，运行环境，构建工具等等。如果只关注一部分，重点关注将会属于你的模块，其他代码了解下即可

章节1:熟悉语法

熟悉C++语法与新特性

熟悉命名规范(变量 函数 类等) ->快速了解作用及含义, 有时通过名字可以看出设计模式等 不用深入探索源码也能知道含义 有文档说明最好 没有也可以靠时间与经验发掘.

章节2:摸清架构(需要拆细)

自上而下,了解全貌而非细节, 了解整个系统架构, 重点关注属于你的模块.

章节3:熟悉工具

熟悉相应的生成/测试工具 编译脚本等, 方便熟悉程序整体功能/流程.

章节4:细看模块(接口 算法需要拆细)

找到程序入口,自上而下抽丝剥茧.

章节5:输出产物

有目的性的阅读可以提高干劲,提前讨论好需要输出/补充的内容,按要求补充/输出成果物.

**2.sylar项目的运行:**

https://www.midlane.top/wiki/pages/viewpage.action?pageId=16416843

按照这个老哥的配置先把这个老哥的项目跑起来（这个项目跟sylar老师讲的差不多）

注意Boost和yaml-cpp的安装，其他安装照上面老哥的来

ubuntu下Boost安装：https://blog.csdn.net/qq_36666115/article/details/131015894

ubuntu下yaml-cpp安装与使用：https://www.cnblogs.com/zwjason/p/17031701.html

**3.项目的流程或者结构理解：**

作者主页：http://www.sylar.top

参考2：https://www.midlane.top/wiki/pages/viewpage.action?pageId=16416843

参考3：流程的理解，感觉这个会好一点：https://juejin.cn/post/7241821748211777593#heading-51

## 问题

- [] 为什么用shared_ptr不用unique_ptr