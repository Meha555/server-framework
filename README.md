# C++高性能服务器框架

## 简介

仿[sylar: C++高性能分布式服务器框架](https://github.com/sylar-yin/sylar)的基于C++17实现的高性能服务器框架。

参考资料：

- [C++高性能服务器框架 – SYLAR – 02日志模块 – sylar的博客](http://www.sylar.top/blog/?p=147)
- [C++_古猜..的博客-CSDN博客](https://blog.csdn.net/qq_35099224/category_12613947.html)
- [日志模块 - 类库与框架 - 程序员的自我修养 (midlane.top)](https://www.midlane.top/wiki/pages/viewpage.action?pageId=10061019#id-日志模块-LogEventWrap)
- [sylar C++高性能服务器框架——日志模块 - 掘金 (juejin.cn)](https://juejin.cn/post/7241821748211777593#heading-51)

## 项目结构

本项目编译生成静态库 `libconet.a`，测试代码在tests下面。

### 日志模块

日志模块：`Logger` 输出日志，是现场构造一个 `LogEvent` ，然后经过 `LogFormatter`，再由 `LogAppender` 输出到目的地。

- `LogEvent`：封装后的日志消息（即日志的元数据）
  - `LogLevel`：日志等级
- `LogFormatter`：日志格式化器
- `LogAppender`：日志输出器
  - `StdoutLogAppender`：标准输出日志输出器
  - `FileLogAppender`：文件日志输出器
- `Logger`：日志器，组合使用上述组件
- `LogConfig`：日志器配置信息类
- `LogAppenderConfig`：日志输出器的配置信息类
- `LogEventWrapper`：日志的RAII风格打印（析构时打印日志）

### 配置模块

用于定义/声明配置项，从配置文件中加载用户配置，并在配置发生变化时自动重新加载

- `ConfigItemBase`：所有配置项的虚基类，提供 `toString/fromString` 公共接口，定义了配置项的名字和描述
- `ConfigItem`：所有配置项的实现类（模板），配置项的值由模板形参决定，配有 `toString/fromString` 方法的实现
- `Config`：解析YAML文件，监听配置项更改，管理所有配置项的单例函数类（没有成员变量，所有的成员函数均为 `static`）
- `meha::lexical_cast`：封装 `boost::lexical_cast` 的类型转换函数为仿函数模板，并为各YAML数据类型特化实现自己的版本，从而实现YAML数据类型和 `string` 的相互转换，用于支撑实现 `toString/fromString` 方法

- [ ] 加入命令行参数
- [ ] 添加正则匹配

### 线程模块

> 为什么不直接使用C++11提供的thread类。按sylar的描述，因为thread其实也是基于pthread实现的。并且C++11里面没有提供读写互斥量，RWMutex，Spinlock等，在高并发场景，这些对象是经常需要用到的，所以选择自己封装pthread。

`Thread`：线程类，构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用`std::bind`进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。

线程同步类（这部分被拆分到mutex.h)中：

- `Semaphore`: 计数信号量，基于`sem_t`实现
- `Mutex`: 互斥锁，基于`pthread_mutex_t`实现
- `RWMutex`: 读写锁，基于`pthread_rwlock_t`实现
- `Spinlock`: 自旋锁，基于`pthread_spinlock_t`实现
- `CASLock`: 原子锁，基于`std::atomic_flag`实现

注意：

- 关于线程入口函数。sylar的线程只支持void(void)类型的入口函数，不支持给线程传参数，但实际使用时可以结合`std::bind`来绑定参数，这样就相当于支持任何类型和数量的参数。

- 关于子线程的执行时机。sylar的线程类可以保证在构造完成之后线程函数一定已经处于运行状态，这是通过一个信号量来实现的，构造函数在创建线程后会一直阻塞，直到线程函数运行并且通知信号量，构造函数才会返回，而构造函数一旦返回，就说明线程函数已经在执行了。

- 关于线程局部变量。sylar的每个线程都有两个线程局部变量，一个用于存储当前线程的Thread指针，另一个存储线程名称，通过Thread::GetThis()可以拿到当前线程的指针。一般都要求线程有名称

- 关于范围锁。sylar大量使用了范围锁来实现互斥，范围锁是指用类的构造函数来加锁，用析造函数来释放锁。这种RAII方式可以简化锁的操作，也可以避免忘记解锁导致的死锁问题，以下是一个范围锁的示例和说明：

  ```cpp
  sylar::Mutex mutex;
  {
      sylar::Mutex::Lock lock(mutex); // 定义lock对象，类型为sylar::Mutex::Lock，传入互斥量，在构造函数中完成加锁操作，如果该锁已经被持有，那构造lock时就会阻塞，直到锁被释放
      //临界区操作
      ...
      // 大括号范围结束，所有在该范围内定义的自动变量都会被回收，lock对象被回收时触发析构函数，在析构函数中释放锁
  }
  ```

- [ ] 线程池（sylar没做线程池是由于该框架主要用协程做高并发的任务）

### 协程模块



## 杂谈

**1.方法论**

1.1如何阅读这个大型项目

（1）先建好环境，让程序能运行，玩一遍

当你拿到一个程序后，即使你不看代码，你也应该知道它是干什么的吧！干啥都不知道，不用看了。

（2）看想办法掌握程序的结构

作者微博、Google、百度、PDSN、等找到程序的体系结构，完整的文档

（3）先体系再细节；先平面再线点。

先整体再局部，先平面再线点。"大胆猜测，小心求证"。在阅读程序的过程中，我们往往对某一处或几处逻辑不肯定，可能是这样，也可能是那样。

（4）断点调试、日志调试。

（5）忽略细节，先前不要关注分支

Main开始一字一句的解读，遇到一个问题，直到他认为这个问题已经处理不再是个问题的时候，才进行下一步。

这是一个做事方法问题：这样无疑会导致整个进度的延缓。若我们一开始只关注整体结构（一个宏观的大概的流程），而忽略掉那些细支末节，则很有利。

那些可以忽略呢？

如有些函数一看函数名便知道是干什么的，没有要一开始便深入。

有些系统中的分支（如某此特殊场景下才执行的逻辑）、不重要的功能，则一扫而过

（6）其它

善用搜索引擎

先整体再局部，先宏观再微观，先流程再细节。



1.2.如何阅读大型项目的C++代码

章节0:了解文档

要搞清楚别人的代码，首先，你要了解代码涉及的领域知识，这是最重要的，不懂领域知识，只看代码本身，不可能搞的明白。

其次，你得找各种文档：需求文档（要做什么），设计文档（怎么做的），先搞清楚你即将要阅读是什么玩意，至少要把代码的整体结构搞清楚：整体架构如何，有几个模块，模块间通信方式，运行环境，构建工具等等。如果只关注一部分，重点关注将会属于你的模块，其他代码了解下即可

章节1:熟悉语法

熟悉C++语法与新特性

熟悉命名规范(变量 函数 类等) ->快速了解作用及含义, 有时通过名字可以看出设计模式等 不用深入探索源码也能知道含义 有文档说明最好 没有也可以靠时间与经验发掘.

章节2:摸清架构(需要拆细)

自上而下,了解全貌而非细节, 了解整个系统架构, 重点关注属于你的模块.

章节3:熟悉工具

熟悉相应的生成/测试工具 编译脚本等, 方便熟悉程序整体功能/流程.

章节4:细看模块(接口 算法需要拆细)

找到程序入口,自上而下抽丝剥茧.

章节5:输出产物

有目的性的阅读可以提高干劲,提前讨论好需要输出/补充的内容,按要求补充/输出成果物.

**2.sylar项目的运行:**

https://www.midlane.top/wiki/pages/viewpage.action?pageId=16416843

按照这个老哥的配置先把这个老哥的项目跑起来（这个项目跟sylar老师讲的差不多）

注意Boost和yaml-cpp的安装，其他安装照上面老哥的来

ubuntu下Boost安装：https://blog.csdn.net/qq_36666115/article/details/131015894

ubuntu下yaml-cpp安装与使用：https://www.cnblogs.com/zwjason/p/17031701.html

**3.项目的流程或者结构理解：**

作者主页：http://www.sylar.top

参考2：https://www.midlane.top/wiki/pages/viewpage.action?pageId=16416843

参考3：流程的理解，感觉这个会好一点：https://juejin.cn/post/7241821748211777593#heading-51

## 问题

- [] 为什么用shared_ptr不用unique_ptr