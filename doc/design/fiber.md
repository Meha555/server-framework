## 协程模块

//TODO: 不存在协程安全，因为同一时刻在单个线程中不可能有多个协程在跑？？？？？回顾一下线程安全的概念

### 协程

> [协程模块 - 类库与框架 - 程序员的自我修养 (midlane.top)](https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060957#id-协程模块-ucontext_t接口)

协程是一种看起来花里胡哨，并且使用起来也花里胡哨的函数，用于在单线程中暂时让出CPU（yield）和获得CPU（resume）来执行不同的代码块，从而实现单线程内的并发。协程切换时主要保存的上下文环境是指寄存器的内容、栈帧的内容。

因此，协程只是利用所属线程的CPU核心来单核并发，并不能像线程那样利用多核并行。属于用户态调度的执行流。

优点：

- 跨平台体系结构
- 无需线程上下文切换的开销（相比线程切换）
- 无需原子操作锁定及同步的开销（相比多线程程序）
- 方便切换控制流，简化编程模型（调用与回调可以在同一个地方写完）
- 高并发+高扩展性+低成本：高性能CPU可以启用非常多的协程，很适合用于高并发处理。

缺点：

- 无法利用多核资源：协程的本质是个单线程，它不能将一个**多核处理器**的的多个核同时用上，协程需要和进程配合才能运行在多CPU上。（线程、多核、超线程参见CSAPP第三版1.9.2并发和并行P17）当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。

- 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个线程

> [【协程第一话】协程到底是怎样的存在？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1b5411b7SD)
>
> [【协程第二话】协程和IO多路复用更配哦~_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1a5411b7aZ)

#### 协程分类

##### 按照调用栈分——有栈协程和无栈协程

> [有栈协程与无栈协程 (mthli.xyz)](https://mthli.xyz/stackful-stackless/)

这里的“栈”**并不是说这个协程运行的时候有没有栈空间，而是说协程之间是否存在函数调用栈，也称执行栈**。因为但凡是个正在运行的程序，不管是协程，还是线程，怎么可能在运行的时候不使用栈空间来创建栈上变量呢。

- 有栈协程（stackful coroutine）：
  - ⽤执行栈来保存协程的上下文信息，相当于用户态线程。切换的成本是用户态线程切换的成本
  - 当协程被挂起时保存当前上下文，并将控制权交还给调度器。当协程被恢复时，栈协程会将之前保存的执行状态恢复，从上次挂起的地⽅继续执行。类似于内核态线程的实现，不同协程间切换还是要切换对应的栈上下文，只是不⽤陷⼊内核⽽已。

- 无栈协程（stackless coroutine）：
  - 没有执行栈来保存协程的上下文信息，相当于可挂起/恢复的函数。切换的成本则相当于函数调用的成本
  - 当协程被挂起时，⽆栈协程会将协程的状态保存在堆上内存中，并将控制权交还给调度器。当协程被恢复时，⽆栈协程会将之前保存的状态从堆中取出，并从上次挂起的地⽅继续执⾏。协程切换时，使⽤状态机来切换，就不⽤切换对应的上
    下⽂了，因为都在堆⾥的。比有栈协程都要轻量许多。

**注意**：

- 不管是有栈还是无栈，其协程栈都在所属线程的堆中，区别只在于调用栈是否共享。
- 由于无栈协程不改变调用栈，因此无法在任意一个嵌套函数中挂起无栈协程，因为既然没有保存栈，则当前多出来的栈帧必须执行完。而有栈协程则没有这个限制，可以在任意嵌套函数中挂起。

##### 按照执行栈分——独立栈和共享栈

独立栈和共享栈都是有栈协程。注意栈空间大小一旦分配后续不可更改。

- 共享栈：所有的协程在运行的时候都使⽤同⼀个，大家都可以读写。
  - 让出CPU时，将共享栈中的内容拷贝出来，保存的时候需要⽤到多少内存就开辟多少，这样就减少了内存的浪费；
  - 恢复该协程的时候，将协程之前保存的栈内容重新拷贝到执行栈中；
  - 使⽤的公共资源内存⽐较大，相对安全，不存在内存碎片，但是协程频繁切换需要进⾏拷贝，耗费CPU。

- 独立栈：每个协程的栈空间都是自己独立的，不会给其他协程共享。
  - 好处是协程切换的时候不用发生内存的拷贝（因为上下文已经在自己的独立栈中了）；
  - 坏处则是内存空间浪费较多。因为栈空间在运行时不能随时扩容，否则如果有指针操作执行了栈内存，扩容后将导致指针失效。为了防止栈内存不够，每个协程都要预先开⼀个足够大的栈空间使⽤，当实际没有使用这么多内存时就造成了浪费；
  - 相对简单，但浪费内存，容易栈溢出。 

##### 按照调度方式分——对称协程和非对称协程

- 对称协程（asymmetric coroutine）：
  - 协程间的调度是任意的，即协程间地位平等，协程与其原调用者没有关系。
  - 实现可以不含协程调度器，此时协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器
- 非对称协程（symmetric coroutine）：
  - 协程让出CPU时只能让回给原调用者。即存在“调用堆栈”的结构
  - 实现一般包含协程调度器

以下表格是都使用调度器下的对称协程和非对称的对比：


|                           对称协程                           |                          非对称协程                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|           协程让出CPU后，可以换入其他任何协程执行            | 协程让出CPU后，只能换入其调用者执行 |
| 只有调度器才能执行 `resume`<br />进入协程之后只能执行 `yield` 操作，把CPU让回调度器 | 协程可以有 `resume` 和 `yield` 两种操作，<br />从谁那里 `resume` 进来的就 `yield` 会那里去 |
| ![img](https://pica.zhimg.com/v2-1b5386fdeae8480977e7f9670c819ea0_r.jpg) | ![img](https://pic1.zhimg.com/v2-170ad18468256f3c05afb93895036fae_1440w.jpg) |

### 协程类架构设计

简单起见，我们不考虑协程间的嵌套。我们设想的是主函数起一个协程A，协程A执行完后返回主函数，主函数再起一个协程B，协程B再返回主函数。显然这是非对称协程，sylar实现的是使用独立栈的版本。

#### 并发安全

由于协程涉及到执行流，因此并发访问临界区自然需要加锁。此时的锁应当是协程级别的锁，才能避免不同协程之间的并发安全。

由于协程们运行在同一个线程中，因此禁止在协程中重复加线程级别的锁，否则就是同一线程内递归上锁导致死锁了。

#### 协程原语

协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。

#### 协程上下文

协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用 `ucontext_t` 结构体表示，配有对应的API。

#### 协程调度

同样是单线程环境下，协程的yield和resume一定是同步进行的，一个协程的yield，必然对应另一个协程的resume，因为线程不可能没有执行主体。并且，协程的yield和resume是完全由应用程序来控制的。与线程不同，线程创建之后，线程的运行和调度也是由操作系统自动完成的，但协程创建后，协程的运行和调度都要由应用程序来完成。

- 所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用起协程的方式运行这个函数；
- 所谓协程调度，其实就是创建一批的协程，然后再创建一个调度协程来调度执行这些协程（协程可以在被调度时继续向调度器添加新的调度任务）；
- 所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；
- 所谓定时器，就是给调度协程预设一个协程对象，等定时时间超时就恢复预设的协程对象。

#### 协程状态

仿照进程的5状态（创建态、就绪态、运行态、阻塞态、终止态）模型，将协程状态简化为4个状态：

```mermaid
graph LR
Initialized -->|第一次调入执行| Ready
Ready -->|resume:获得处理机调入执行| Running
Running -->|yield:放弃处理机加入调度| Ready
Running -->|协程函数运行结束| Terminated
```

- 创建态INIT：协程刚创建，还没有开始执行（只相当于标记位，调入会直接变到EXEC）
- 就绪态READY：协程函数还没有开始执行（可能是刚创建，或被挂起）
- 运行态EXEC：协程函数正在执行
- 终止态TERM：协程函数运行结束

设计成这样是基于几点考虑：

1. INIT和TERM是由于`reset`重置协程函数不应在协程函数已经执行过的情况下重置，因此需要区分状态
2. 由于协程属于用户态调度执行的，隶属于线程，因此不应调用线程原语阻塞，所谓的协程阻塞行为应该由用户态调度器`Scheduler`自行管理和实现

#### 协程类设计

本部分是基于glibc的 `ucontext_t` 实现非对称协程。即**子协程只能和主协程切换，而不能和另一个子协程切换。由主协程选出一个子协程来调度运行，而不允许子协程有调度其他协程的能力**。并且在程序结束时，一定要再切回主协程，以保证程序能正常结束，像下面这样：

![image](https://img2024.cnblogs.com/blog/3077699/202406/3077699-20240610230857545-699286863.png)

sylar使用线程局部变量（C++11`thread_local`变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。

对于每个线程的协程上下文，sylar设计了两个线程局部变量来存储协程上下文信息（对应源码的`t_current_fiber`和`t_master_fiber`），也就是说，一个线程在任何时候最多只能知道两个协程的上下文（当前执行的和主协程的），前者用于调度执行当前协程，后者用于切回主协程。

sylar的非对称协程代码实现简单，并且在后面实现协程调度时可以做到公平调度，缺点是子协程只能和线程主协程切换，意味着子协程无法创建并运行新的子协程，并且在后面实现协程调度时，完成一次子协程调度需要先切换回主协程，这会额外多切换一次上下文。

#### 协程类实现

> [linux ucontext族函数的原理及使用_ucontext排查短促-CSDN博客](https://blog.csdn.net/qq_44443986/article/details/117739157)

（1）`ucontext_t` 结构体定义

```c
// 上下文结构体是平台相关的，因为不同平台的寄存器不一样
// 下面列出的是所有平台都至少会包含的4个成员
typedef struct ucontext_t {
    struct ucontext_t *uc_link;   // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效
    sigset_t          uc_sigmask; // 当前上下文的信号屏蔽掩码
    stack_t           uc_stack;   // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效
    mcontext_t        uc_mcontext;// 平台相关的上下文具体内容，包含当前线程寄存器的值
    ...
} ucontext_t;

// 寄存器值结构体
typedef struct {
    gregset_t __ctx(gregs);   // 所装载寄存器
    fpregset_t __ctx(fpregs); // 寄存器的类型
} mcontext_t;

// 栈内存结构体
typedef struct {
    void *ss_sp;  // 栈顶指针
    int ss_flags; // 备用栈状态
    size_t ss_size; // 栈空间大小
} stack_t;
```

（2）配套API

> 注意不能存在某时刻没有执行实体

```c
// 获取当前的上下文
int getcontext(ucontext_t *ucp);
 
// 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
int setcontext(const ucontext_t *ucp);
 
// 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数。
// 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间；
// 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文；如果uc_link == NULL，那func函数结束时当前线程也会退出
// makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行
void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);
 
// 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，
// 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数
// swapcontext是非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换
int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);
```

（3）简单示例

```c
#include <stdio.h>
#include <ucontext.h>

// 此函数用来给makecontext使用
void fiber1(void *arg) {
  puts("fiber1");
}

void context_test() {
  char stack[1024 * 128]; // 分配协程独立栈的空间
  ucontext_t child, main; // 设置两个协程上下文
  getcontext(&child); // 将此时协程上下文信息保存到child中，用于赋值
  child.uc_stack.ss_sp = stack;           // 指定栈内存
  child.uc_stack.ss_size = sizeof(stack); // 指定栈空间大小
  child.uc_stack.ss_flags = 0;
  child.uc_link = &main; // 设置后继协程上下文
  makecontext(&child, (void (*)(void))fiber1,
              0);             // 修改上下文让其指向fiber1函数
  swapcontext(&main, &child); // 切换到child上下文（fiber1函数），保存当前上下文到main
  puts("main"); // 执行完成后会返回此处打印main，如果指向后继上下文为nullptr就直接结束
}

int main() {
  context_test();
  /*输出：
  fiber1
  main
  */
  return 0;
}
```

可以发现 `getcontext` 和 `makecontext` 是成对出现的并且要在 `makecontext` 中保存好当前上下文 `ucontext_t` 结构体对象的值并填入新上下文的结构体对象。