## 协程调度器模块

#### 协程调度器

实现了一个 $N:M$ 的协程调度器，$N$ 个线程运行 $M$ 个协程，协程可以在线程之间进行切换，也可以绑定到指定线程运行。

```
         1 —— N      1 —— M
scheduler ---> thread ---> fiber
​
N : M 协程可以在线程间自由切换
1. 线程池，分配一组线程
2. 协程调度器，将协程指定到相应线程上执行
    a）调度器随机选择空闲的协程执行
    b）协程指定必须在某个线程上执行
```

##### 为什么需要协程调度器

> 在前面的协程模块中，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程yield并返回，再运行下一个协程。这种运行协程的方式其实是用户自己充当调度器，非常麻烦。

实现协程调度之后，可以先创建一个协程调度器，然后把要调度的协程传递给调度器，由**调度器负责创建线程来调度执行这些协程**。还能解决协程模块中子协程不能直接运行另一个子协程的缺陷，子协程可以通过向调度器添加调度任务的方式来运行另一个子协程。

##### 一些设计层面的考虑

调度器创建后，内部首先会创建一个线程池。调度开始后，所有工作线程按加入线程池的顺序从任务队列中取任务并以协程的方式执行。工作线程数越多噢，能同时调度的任务也越多，当所有任务都调度执行完后，工作线程就会执行idle协程，等待新的任务加入。

**调度任务**：

- 这里认为所有可运行的实体都是调度任务，但是以协程为基本执行单位（这些协程称为任务协程）。因此函数要想执行，必须得先构造为协程
- 此外，还涉及到添加调度任务，发现调度任务，通知任务完成

**三类协程**：

- 主协程：原本的程序执行流
- 调度协程：负责调度任务协程的协程，即调度线程的执行体
- 任务协程：执行任务的协程
  - idle协程：工作线程空转时执行的协程

**工作线程**：

- 执行任务的任务协程和负责调度任务协程的调度者协程都是需要跑在线程里的，这个线程叫做工作线程

**多线程加速**：

- 一个线程同一时刻只能运行一个协程，而如果有多个线程就意味着有多个协程可以同时执行，因此协程调度器如果支持在多个线程内调度协程执行任务协程显然能大幅提升效率。【暂不考虑多个任务线程的负载均衡】
- 线程切换存在开销，因此线程数要尽可能少。如果能尽可能利用调度器所在线程那就可以白嫖一个线程作为调度线程（主协程）【这里认为每个调度协程都有一个调度协程】

因此，`Scheduler` 分为：

- 任务队列：需要调度执行的任务
- 调度线程池：调度器事先创建好的线程池，其中线程作为调度线程。每当在存在调度任务时**调度线程的调度协程**从任务队列中取出任务执行，没有任务时就阻塞等待。执行完所有任务后随着调度器整体销毁。

|                                                                                                          不利用调度者线程的情况                                                                                                          |                                                                                                                利用调度者线程的情况                                                                                                                 |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|                                                                    ![image](https://img2024.cnblogs.com/blog/3077699/202407/3077699-20240721215332627-702521131.png)                                                                     |                                                                          ![image](https://img2024.cnblogs.com/blog/3077699/202407/3077699-20240721215406824-345601220.png)                                                                          |
|                                                                          用单独的调度线程用于跑调度协程：调度者线程中只有主协程，调度线程中有调度协程和任务协程                                                                          |                                                                               利用调度器所在线程作为调度线程跑调度协程：调度器所在线程中有主协程、调度协程和任务协程                                                                                |
|                                                                                                                实现较简单                                                                                                                |                                                                                                                     实现较困难                                                                                                                      |
| 只需要让新线程的入口函数作为调度协程，从任务队列⾥取任务执行即可， 原本调度器所在线程的主协程与调度协程完全不相关，主协程只需要向调度器添加任务，然后在适当的时机停⽌调度器即可。当调度器停⽌时，调度器所在线程要等待调度线程结束后再退出。 | 由于sylar是非对称协程，因此原本不允许调度协程和任务协程直接切换。而主协程本身是没有调度逻辑的，因此应当让调度协程和任务协程之间可以直接切换。因此需要添加第三个线程局部变量，从而同时记录当前执行的协程、主协程、调度协程，确保主协程的信息不丢失。 |

*利用调度者协程的情况费了那么大劲，到底是防止主协程承担调度的逻辑，否则就又回到了原本用户充当调度器的情况。*

**idle如何处理，也就是当调度器没有协程可调度时，调度协程该怎么办**

直觉上来看这里应该有一些同步手段，比如，没有调度任务时，调度协程阻塞住，比如阻塞在一个idle协程上，等待新任务加入后退出idle协程，恢复调度。然而这种方案是无法实现的，因为每个线程同一时间只能有一个协程在执行，如果调度线程阻塞在idle协程上，那么除非idle协程自行让出执行权，否则其他的协程都得不到执行，这里就造成了一个先有鸡还是先有蛋的问题：只有创建新任务idle协程才会退出，只有idle协程退出才能创建新任务。为了解决这个问题，sylar采取了一个简单粗暴的办法，如果任务队列空了，调度协程会不停地检测任务队列，看有没有新任务，俗称忙等待，CPU使用率爆表。这点可以从sylar的源码上发现，一是Scheduler的tickle函数什么也不做，因为根本不需要通知调度线程是否有新任务，二是idle协程在协程调度器未停止的情况下只会yield to hold，而调度协程又会将idle协程重新swapIn，相当于idle啥也不做直接返回。这个问题在sylar框架内无解，只有一种方法可以规避掉，那就是设置autostop标志，这个标志会使得调度器在调度完所有任务后自动退出。在后续的IOManager中，上面的问题会得到一定的改善，并且tickle和idle可以实现得更加巧妙一些，以应对IO事件。

**任务的调度时机**

归纳起来，如果只使用caller线程进行调度，那所有的任务协程都在stop之后排队调度，如果有额外线程，那任务协程在刚添加到任务队列时就可以得到调度。

- 只有main函数线程参与调度时的调度执行时机。

  前面说过，当只有main函数线程参与调度时，可以认为是主线程先攒下一波协程，然后切到调度协程开始调度这些协程，等所有的协程都调度完了，调度协程进idle状态，这个状态下调度器只能执行忙等待，啥也做不了。这也就是说，主线程main函数一旦开启了协程调度，就无法回头了，位于开始调度点之后的代码都执行不到。对于这个问题，sylar把调度器的开始点放在了stop方法中，也就是，调度开始即结束，干完活就下班。IOManager也是类似，除了可以调用stop方法外，IOManager类的析构函数也有一个stop方法，可以保证所有的任务都会被调度到。

- 额外创建了调度线程时的调度执行时机。

  如果不额外创建线程，也就是线程数为1并且use caller，那所有的调度任务都在stop()时才会进行调度。但如果额外创建了线程，那么，在添加完调度任务之后任务马上就可以在另一个调度线程中调度执行。

TODO:

- [x] 协程调度器
- [ ] 支持内存池

#### IO协程调度器

> 利用管道统一事件源，将套接字就绪的回调函数作为协程。

##### 套接字就绪与事件回调

sylar支持两类事件，一类是可读事件，对应`EPOLLIN`，一类是可写事件，对应`EPOLLOUT`，sylar的事件枚举值直接继承自epoll。对于epoll其他的事件，全部归类到这两类事件之中，甚至有的事件还可以同时表示可读及可写事件，比如`EPOLLERR`事件发生时，fd将同时触发可读和可写事件。

内核上报套接字就绪后，我们需要执行对应的业务动作，这就需要在框架中加入事件回调的机制，然后将这些回调函数以协程的方式执行，这就实现了IO操作和协程的结合：在等待套接字就绪时，我可以换入其他协程执行；而套接字就绪时，我可以换入回调函数作为协程执行。

对于IO协程调度来说，每次调度都包含一个三元组信息，分别是描述符-事件类型-回调函数，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于`epoll_wait`，回调函数用于协程调度。这个三元组信息在源码上通过`FdContext`结构体来存储，在执行`epoll_wait`时通过`epoll_event`的私有数据指针`data.ptr`来保存`FdContext`结构体信息。

IO协程调度器在idle时会`epoll_wait`所有注册的fd，如果有fd就绪，`epoll_wait`返回，从私有数据中拿到fd的上下文信息，并且执行其中的回调函数。（实际是idle协程只负责收集所有已触发的fd的回调函数并将其加入调度器的任务队列，真正的回调函数执行时机是idle协程退出后，调度器在下一轮调度时执行）

与协程调度器不一样的是，IO协程调度器支持取消事件。取消事件表示不关心某个fd的某个事件了，如果某个fd的可读或可写事件都被取消了，那这个fd会从调度器的`epoll_wait`中删除。【协程调度器只能删除已被执行完的任务】。此外还多了一个外挂的定时器来处理定时任务，如`sleep/usleep`等。

##### 阻塞和触发模式的选择

> 精华帖：[为什么 IO 多路复用要搭配非阻塞 IO? - 知乎 (zhihu.com)](https://www.zhihu.com/question/37271342)