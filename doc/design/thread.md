## 线程模块

### TODO

- [ ] 添加线程池（sylar没做线程池是由于该框架主要用协程做高并发的任务）
- [ ] 合理设定创建线程和协程失败时是否是致命错误

### 设计思想

> 为什么不直接使用C++11提供的thread类。按sylar的描述，因为thread其实也是基于pthread实现的。并且C++11里面没有提供读写互斥锁RWMutex，Spinlock等，而在高并发场景这些对象是经常需要用到的，所以选择自己封装pthread。

`Thread`：线程类，构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用 `std::bind` 构造偏函数。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。

线程同步类（这部分被拆分到mutex.h）中：

- `Semaphore`: 计数信号量，基于`sem_t`实现
- `Mutex`: 互斥锁，基于`pthread_mutex_t`实现
- `RWMutex`: 读写锁，基于`pthread_rwlock_t`实现
- `Spinlock`: 自旋锁，基于`pthread_spinlock_t`实现
- `CASLock`: 原子锁，基于`std::atomic_flag`实现

#### 技巧

- **线程入口函数**。sylar的线程只支持 `void(void)` 类型的入口函数，不支持给线程传参数，但实际使用时可以结合 `std::bind` 来绑定参数，这样就相当于支持任何类型和数量的参数。

- **线程工作函数**。sylar的线程和 `QThead` 类似，本身是OS线程的管理类，不代表线程本身，因此线程执行的函数体实际上需要作为线程类的一个静态成员函数实现。

- **子线程的执行时机**。sylar的线程类可以保证在构造完成之后线程函数一定已经处于运行状态，这是通过一个信号量来实现的，构造函数在创建线程后会一直阻塞，直到线程函数运行并且通知信号量，构造函数才会返回，而构造函数一旦返回，就说明线程函数已经在执行了。

- **线程局部变量**。sylar的每个线程都有两个线程局部变量，一个用于存储当前线程的Thread指针，另一个存储线程名称，通过 `Thread::GetThis()` 可以拿到当前线程的指针。一般都要求线程有名称
  - 注意：**由于 `static thread_local` 静态线程本地存储变量是线程特定的，因此它们的初始化和销毁时机也与普通静态变量不同。具体来说，在每个线程首次访问该变量时会进行初始化，在线程结束时才会进行销毁，而不是在程序启动或运行期间进行一次性初始化或销毁。**

- **范围锁**。sylar大量使用了范围锁来实现互斥，范围锁是指用类的构造函数来加锁，用析造函数来释放锁。这种RAII方式可以简化锁的操作，也可以避免忘记解锁导致的死锁问题。
